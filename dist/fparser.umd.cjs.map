{"version":3,"file":"fparser.umd.cjs","sources":["../src/fparser.ts"],"sourcesContent":["/**\n * JS Formula Parser\n * -------------------\n * (c) 2012-2023 Alexander Schenkel, alex@alexi.ch\n *\n * JS Formula Parser takes a string, parses its mathmatical formula\n * and creates an evaluatable Formula object of it.\n *\n * Example input:\n *\n * var fObj = new Formula('sin(PI*x)/(2*PI)');\n * var result = fObj.evaluate({x: 2});\n * var results = fObj.evaluate([\n *     {x: 2},\n *     {x: 4},\n *     {x: 8}\n * ]);\n *\n * LICENSE:\n * -------------\n * MIT license, see LICENSE file\n */\nconst MATH_CONSTANTS = {\n    PI: Math.PI,\n    E: Math.E,\n    LN2: Math.LN2,\n    LN10: Math.LN10,\n    LOG2E: Math.LOG2E,\n    LOG10E: Math.LOG10E,\n    SQRT1_2: Math.SQRT1_2,\n    SQRT2: Math.SQRT2\n};\n\ndeclare global {\n    interface Math {\n        [key: string]: number | Function;\n    }\n}\n\ntype FormulaOptions = {\n    memoization?: boolean;\n};\n\ntype ValueObject = {\n    [key: string]: number | Function | ValueObject;\n};\n\nclass Expression {\n    static createOperatorExpression(operator: string, left: Expression, right: Expression) {\n        if (operator === '^') {\n            return new PowerExpression(left, right);\n        }\n        if (operator === '*' || operator === '/') {\n            return new MultDivExpression(operator, left, right);\n        }\n        if (operator === '+' || operator === '-') {\n            return new PlusMinusExpression(operator, left, right);\n        }\n        throw new Error(`Unknown operator: ${operator}`);\n    }\n\n    evaluate(params: ValueObject = {}): number {\n        throw new Error('Empty Expression - Must be defined in child classes');\n    }\n\n    toString() {\n        return '';\n    }\n}\n\nclass BracketExpression extends Expression {\n    innerExpression: Expression;\n\n    constructor(expr: Expression) {\n        super();\n        this.innerExpression = expr;\n        if (!(this.innerExpression instanceof Expression)) {\n            throw new Error('No inner expression given for bracket expression');\n        }\n    }\n    evaluate(params = {}): number {\n        return this.innerExpression.evaluate(params);\n    }\n    toString() {\n        return `(${this.innerExpression.toString()})`;\n    }\n}\n\nclass ValueExpression extends Expression {\n    value: number;\n\n    constructor(value: number | string) {\n        super();\n        this.value = Number(value);\n        if (isNaN(this.value)) {\n            throw new Error('Cannot parse number: ' + value);\n        }\n    }\n    evaluate(): number {\n        return this.value;\n    }\n    toString() {\n        return String(this.value);\n    }\n}\n\nclass PlusMinusExpression extends Expression {\n    operator: string;\n    left: Expression;\n    right: Expression;\n\n    constructor(operator: string, left: Expression, right: Expression) {\n        super();\n        if (!['+', '-'].includes(operator)) {\n            throw new Error(`Operator not allowed in Plus/Minus expression: ${operator}`);\n        }\n        this.operator = operator;\n        this.left = left;\n        this.right = right;\n    }\n\n    evaluate(params: ValueObject = {}): number {\n        if (this.operator === '+') {\n            return this.left.evaluate(params) + this.right.evaluate(params);\n        }\n        if (this.operator === '-') {\n            return this.left.evaluate(params) - this.right.evaluate(params);\n        }\n        throw new Error('Unknown operator for PlusMinus expression');\n    }\n\n    toString() {\n        return `${this.left.toString()} ${this.operator} ${this.right.toString()}`;\n    }\n}\n\nclass MultDivExpression extends Expression {\n    operator: string;\n    left: Expression;\n    right: Expression;\n\n    constructor(operator: string, left: Expression, right: Expression) {\n        super();\n        if (!['*', '/'].includes(operator)) {\n            throw new Error(`Operator not allowed in Multiply/Division expression: ${operator}`);\n        }\n        this.operator = operator;\n        this.left = left;\n        this.right = right;\n    }\n\n    evaluate(params: ValueObject = {}): number {\n        if (this.operator === '*') {\n            return this.left.evaluate(params) * this.right.evaluate(params);\n        }\n        if (this.operator === '/') {\n            return this.left.evaluate(params) / this.right.evaluate(params);\n        }\n        throw new Error('Unknown operator for MultDiv expression');\n    }\n\n    toString() {\n        return `${this.left.toString()} ${this.operator} ${this.right.toString()}`;\n    }\n}\n\nclass PowerExpression extends Expression {\n    base: Expression;\n    exponent: Expression;\n\n    constructor(base: Expression, exponent: Expression) {\n        super();\n        this.base = base;\n        this.exponent = exponent;\n    }\n\n    evaluate(params: ValueObject = {}): number {\n        return Math.pow(this.base.evaluate(params), this.exponent.evaluate(params));\n    }\n\n    toString() {\n        return `${this.base.toString()}^${this.exponent.toString()}`;\n    }\n}\nclass FunctionExpression extends Expression {\n    fn: string;\n    varPath: string[];\n    argumentExpressions: Expression[];\n    formulaObject: Formula | null;\n    blacklisted: boolean | undefined;\n\n    constructor(fn: string | null, argumentExpressions: Expression[], formulaObject: Formula | null = null) {\n        super();\n        this.fn = fn ?? '';\n        this.varPath = this.fn.split('.');\n        this.argumentExpressions = argumentExpressions || [];\n        this.formulaObject = formulaObject;\n        this.blacklisted = undefined;\n    }\n\n    evaluate(params: ValueObject = {}): number {\n        params = params || {};\n        const paramValues = this.argumentExpressions.map((a) => a.evaluate(params));\n\n        // If the params object itself has a function definition with\n        // the function name, call this one:\n        // let fn = params[this.fn];\n        try {\n            let fn = getProperty(params, this.varPath, this.fn);\n            if (fn instanceof Function) {\n                return fn.apply(this, paramValues);\n            }\n        } catch (e) {\n            // pass: getProperty has found nothing, which throws an error, but\n            // we need to continue\n        }\n\n        let objFn;\n        try {\n            // perhaps the Formula object has the function? so call it:\n            objFn = getProperty(this.formulaObject ?? {}, this.varPath, this.fn);\n        } catch (e) {\n            // pass: getProperty has found nothing, which throws an error, but\n            // we need to continue\n        }\n        if (this.formulaObject && objFn instanceof Function) {\n            // Don't, if it is blacklisted:\n            if (this.isBlacklisted()) {\n                throw new Error('Blacklisted function called: ' + this.fn);\n            }\n            return objFn.apply(this.formulaObject, paramValues);\n        }\n\n        try {\n            // Has the JS Math object a function as requested? Call it:\n            const mathFn = getProperty(Math, this.varPath, this.fn);\n            if (mathFn instanceof Function) {\n                return mathFn.apply(this, paramValues);\n            }\n        } catch (e) {\n            // pass: getProperty has found nothing, which throws an error, but\n            // we need to continue\n        }\n        // No more options left: sorry!\n        throw new Error('Function not found: ' + this.fn);\n    }\n\n    toString() {\n        return `${this.fn}(${this.argumentExpressions.map((a) => a.toString()).join(', ')})`;\n    }\n\n    isBlacklisted() {\n        // cache evaluation of blacklisted function, to save call time:\n        if (this.blacklisted === undefined) {\n            this.blacklisted = Formula.functionBlacklist.includes(\n                this.formulaObject ? this.formulaObject[this.fn] : null\n            );\n        }\n        return this.blacklisted;\n    }\n}\n\nfunction getProperty(object: ValueObject, path: string[], fullPath: string) {\n    let curr: number | Function | ValueObject = object;\n    for (let propName of path) {\n        if (typeof curr !== 'object') {\n            throw new Error(`Cannot evaluate ${propName}, property not found (from path ${fullPath})`);\n        }\n        if (curr[propName] === undefined) {\n            throw new Error(`Cannot evaluate ${propName}, property not found (from path ${fullPath})`);\n        }\n        curr = curr[propName];\n    }\n\n    if (typeof curr === 'object') {\n        throw new Error('Invalid value');\n    }\n\n    return curr;\n}\n\nclass VariableExpression extends Expression {\n    fullPath: string;\n    varPath: string[];\n    formulaObject: Formula | null;\n\n    constructor(fullPath: string, formulaObj: Formula | null = null) {\n        super();\n        this.formulaObject = formulaObj;\n        this.fullPath = fullPath;\n        this.varPath = fullPath.split('.');\n    }\n\n    evaluate(params = {}) {\n        // params contain variable / value pairs: If this object's variable matches\n        // a varname found in the params, return the value.\n        // eg: params = {x: 5,y:3}, varname = x, return 5\n        // Objects and arrays are also supported:\n        // e.g. params = {x: {y: 5}}, varname = x.y, return 5\n        //  or  params = {x: [2,4,6]}, varname = x.2, return 6\n\n        // Let's look in the value object first:\n        let value = undefined;\n        try {\n            value = getProperty(params, this.varPath, this.fullPath);\n        } catch (e) {\n            // pass: getProperty has found nothing, which throws an error, but\n            // we need to continue\n        }\n        if (value === undefined) {\n            // Now have a look at the formula object:\n            // This will throw an error if the property is not found:\n            value = getProperty(this.formulaObject ?? {}, this.varPath, this.fullPath);\n        }\n        if (typeof value === 'function' || typeof value === 'object') {\n            throw new Error(`Cannot use ${this.fullPath} as value: It contains a non-numerical value.`);\n        }\n\n        return Number(value);\n    }\n    toString() {\n        return `${this.varPath.join('.')}`;\n    }\n}\n\nexport default class Formula {\n    [key: string]: any;\n    static Expression = Expression;\n    static BracketExpression = BracketExpression;\n    static PowerExpression = PowerExpression;\n    static MultDivExpression = MultDivExpression;\n    static PlusMinusExpression = PlusMinusExpression;\n    static ValueExpression = ValueExpression;\n    static VariableExpression = VariableExpression;\n    static FunctionExpression = FunctionExpression;\n    static MATH_CONSTANTS = MATH_CONSTANTS;\n\n    // Create a function blacklist:\n    static functionBlacklist = Object.getOwnPropertyNames(Formula.prototype)\n        .filter((prop) => Formula.prototype[prop] instanceof Function)\n        .map((prop) => Formula.prototype[prop]);\n\n    public formulaExpression: Expression | null;\n    public options: FormulaOptions;\n    public formulaStr: string;\n    private _variables: string[];\n    private _memory: { [key: string]: number };\n\n    /**\n     * Creates a new Formula instance\n     *\n     * Optional configuration can be set in the options object:\n     *\n     * - memoization (bool): If true, results are stored and re-used when evaluate() is called with the same parameters\n     *\n     * @param {String} fStr The formula string, e.g. 'sin(x)/cos(y)'\n     * @param {Object} options An options object. Supported options:\n     *    - memoization (bool): If true, results are stored and re-used when evaluate() is called with the same parameters\n     * @param {Formula} parentFormula Internally used to build a Formula AST\n     */\n    constructor(fStr: string, options: FormulaOptions | null = {}) {\n        this.formulaExpression = null;\n        this.options = { ...{ memoization: false }, ...options };\n        this.formulaStr = '';\n        this._variables = [];\n        this._memory = {};\n        this.setFormula(fStr);\n    }\n\n    /**\n     * Re-sets the given String and parses it to a formula expression. Can be used after initialization,\n     * to re-use the Formula object.\n     *\n     * @param {String} formulaString The formula string to set/parse\n     * @return {this} The Formula object (this)\n     */\n    setFormula(formulaString: string) {\n        if (formulaString) {\n            this.formulaExpression = null;\n            this._variables = [];\n            this._memory = {};\n            this.formulaStr = formulaString;\n            this.formulaExpression = this.parse(formulaString);\n        }\n        return this;\n    }\n\n    /**\n     * Enable memoization: An expression is only evaluated once for the same input.\n     * Further evaluations with the same input will return the in-memory stored result.\n     */\n    enableMemoization() {\n        this.options.memoization = true;\n    }\n\n    /**\n     * Disable in-memory memoization: each call to evaluate() is executed from scratch.\n     */\n    disableMemoization() {\n        this.options.memoization = false;\n        this._memory = {};\n    }\n\n    /**\n     * Splits the given string by ',', makes sure the ',' is not within\n     * a sub-expression\n     * e.g.: str = \"x,pow(3,4)\" returns 2 elements: x and pow(3,4).\n     */\n    splitFunctionParams(toSplit: string) {\n        // do not split on ',' within matching brackets.\n        let pCount = 0,\n            paramStr = '';\n        const params = [];\n        for (let chr of toSplit.split('')) {\n            if (chr === ',' && pCount === 0) {\n                // Found function param, save 'em\n                params.push(paramStr);\n                paramStr = '';\n            } else if (chr === '(') {\n                pCount++;\n                paramStr += chr;\n            } else if (chr === ')') {\n                pCount--;\n                paramStr += chr;\n                if (pCount < 0) {\n                    throw new Error('ERROR: Too many closing parentheses!');\n                }\n            } else {\n                paramStr += chr;\n            }\n        }\n        if (pCount !== 0) {\n            throw new Error('ERROR: Too many opening parentheses!');\n        }\n        if (paramStr.length > 0) {\n            params.push(paramStr);\n        }\n        return params;\n    }\n\n    /**\n     * Cleans the input string from unnecessary whitespace,\n     * and replaces some known constants:\n     */\n    cleanupInputString(s: string) {\n        s = s.replace(/\\s+/g, '');\n        // surround known math constants with [], to parse them as named variables [xxx]:\n        Object.keys(MATH_CONSTANTS).forEach((c) => {\n            s = s.replace(new RegExp(`\\\\b${c}\\\\b`, 'g'), `[${c}]`);\n        });\n        return s;\n    }\n\n    /**\n     * Parses the given formula string by using a state machine into a single Expression object,\n     * which represents an expression tree (aka AST).\n     *\n     * First, we split the string into 'expression': An expression can be:\n     *   - a number, e.g. '3.45'\n     *   - an unknown variable, e.g. 'x'\n     *   - a single char operator, such as '*','+' etc...\n     *   - a named variable, in [], e.g. [myvar]\n     *   - a function, such as sin(x)\n     *   - a parenthessed expression, containing other expressions\n     *\n     * We want to create an expression tree out of the string. This is done in 2 stages:\n     * 1. form single expressions from the string: parse the string into known expression objects:\n     *   - numbers/variables\n     *   - operators\n     *   - braces (with a sub-expression)\n     *   - functions (with sub-expressions (aka argument expressions))\n     *   This will lead to an array of expressions.\n     *  As an example:\n     *  \"2 + 3 * (4 + 3 ^ 5) * sin(PI * x)\" forms an array of the following expressions:\n     *  `[2, +, 3, *, bracketExpr(4,+,3,^,5), * , functionExpr(PI,*,x)]`\n     * 2. From the raw expression array we form an expression tree by evaluating the expressions in the correct order:\n     *    e.g.:\n     *  the expression array `[2, +, 3, *, bracketExpr(4,+,3,^,5), * , functionExpr(PI,*,x)]` will be transformed into the expression tree:\n     *  ```\n     *         root expr:  (+)\n     *                     / \\\n     *                    2    (*)\n     *                        / \\\n     *                     (*)  functionExpr(...)\n     *                     / \\\n     *                    3   (bracket(..))\n     * ```\n     *\n     * In the end, we have a single root expression node, which then can be evaluated in the evaluate() function.\n     *\n     * @param {String} str The formula string, e.g. '3*sin(PI/x)'\n     * @returns {Expression} An expression object, representing the expression tree\n     */\n    parse(str: string) {\n        // clean the input string first. spaces, math constant replacements etc.:\n        str = this.cleanupInputString(str);\n        // start recursive call to parse:\n        return this._do_parse(str);\n    }\n\n    /**\n     * @see parse(): this is the recursive parse function, without the clean string part.\n     * @param {String} str\n     * @returns {Expression} An expression object, representing the expression tree\n     */\n    _do_parse(str: string): Expression {\n        let lastChar = str.length - 1,\n            act = 0,\n            state:\n                | 'initial'\n                | 'within-nr'\n                | 'within-parentheses'\n                | 'within-func-parentheses'\n                | 'within-named-var'\n                | 'within-expr'\n                | 'within-bracket'\n                | 'within-func'\n                | 'invalid' = 'initial',\n            expressions = [],\n            char = '',\n            tmp = '',\n            funcName = null,\n            pCount = 0;\n\n        while (act <= lastChar) {\n            switch (state) {\n                case 'initial':\n                    // None state, the beginning. Read a char and see what happens.\n                    char = str.charAt(act);\n                    if (char.match(/[0-9.]/)) {\n                        // found the beginning of a number, change state to \"within-number\"\n                        state = 'within-nr';\n                        tmp = '';\n                        act--;\n                    } else if (this.isOperator(char)) {\n                        // Simple operators. Note: '-' must be treaten specially,\n                        // it could be part of a number.\n                        // it MUST be part of a number if the last found expression\n                        // was an operator (or the beginning):\n                        if (char === '-') {\n                            if (expressions.length === 0 || this.isOperatorExpr(expressions[expressions.length - 1])) {\n                                state = 'within-nr';\n                                tmp = '-';\n                                break;\n                            }\n                        }\n\n                        // Found a simple operator, store as expression:\n                        if (act === lastChar || this.isOperatorExpr(expressions[expressions.length - 1])) {\n                            state = 'invalid'; // invalid to end with an operator, or have 2 operators in conjunction\n                            break;\n                        } else {\n                            expressions.push(\n                                Expression.createOperatorExpression(char, new Expression(), new Expression())\n                            );\n                            state = 'initial';\n                        }\n                    } else if (char === '(') {\n                        // left parenthes found, seems to be the beginning of a new sub-expression:\n                        state = 'within-parentheses';\n                        tmp = '';\n                        pCount = 0;\n                    } else if (char === '[') {\n                        // left named var separator char found, seems to be the beginning of a named var:\n                        state = 'within-named-var';\n                        tmp = '';\n                    } else if (char.match(/[a-zA-Z]/)) {\n                        // multiple chars means it may be a function, else its a var which counts as own expression:\n                        if (act < lastChar && str.charAt(act + 1).match(/[a-zA-Z0-9_.]/)) {\n                            tmp = char;\n                            state = 'within-func';\n                        } else {\n                            // Single variable found:\n                            // We need to check some special considerations:\n                            // - If the last char was a number (e.g. 3x), we need to create a multiplication out of it (3*x)\n                            if (\n                                expressions.length > 0 &&\n                                expressions[expressions.length - 1] instanceof ValueExpression\n                            ) {\n                                expressions.push(\n                                    Expression.createOperatorExpression('*', new Expression(), new Expression())\n                                );\n                            }\n                            expressions.push(new VariableExpression(char, this));\n                            this.registerVariable(char);\n                            state = 'initial';\n                            tmp = '';\n                        }\n                    }\n                    break;\n                case 'within-nr':\n                    char = str.charAt(act);\n                    if (char.match(/[0-9.]/)) {\n                        //Still within number, store and continue\n                        tmp += char;\n                        if (act === lastChar) {\n                            expressions.push(new ValueExpression(tmp));\n                            state = 'initial';\n                        }\n                    } else {\n                        // Number finished on last round, so add as expression:\n                        if (tmp === '-') {\n                            // just a single '-' means: a variable could follow (e.g. like in 3*-x), we convert it to -1: (3*-1x)\n                            tmp = '-1';\n                        }\n                        expressions.push(new ValueExpression(tmp));\n                        tmp = '';\n                        state = 'initial';\n                        act--;\n                    }\n                    break;\n\n                case 'within-func':\n                    char = str.charAt(act);\n                    if (char.match(/[a-zA-Z0-9_.]/)) {\n                        tmp += char;\n                    } else if (char === '(') {\n                        funcName = tmp;\n                        tmp = '';\n                        pCount = 0;\n                        state = 'within-func-parentheses';\n                    } else {\n                        throw new Error('Wrong character for function at position ' + act);\n                    }\n\n                    break;\n\n                case 'within-named-var':\n                    char = str.charAt(act);\n                    if (char === ']') {\n                        // end of named var, create expression:\n                        expressions.push(new VariableExpression(tmp, this));\n                        this.registerVariable(tmp);\n                        tmp = '';\n                        state = 'initial';\n                    } else if (char.match(/[a-zA-Z0-9_.]/)) {\n                        tmp += char;\n                    } else {\n                        throw new Error('Character not allowed within named variable: ' + char);\n                    }\n                    break;\n\n                case 'within-parentheses':\n                case 'within-func-parentheses':\n                    char = str.charAt(act);\n                    if (char === ')') {\n                        //Check if this is the matching closing parenthesis.If not, just read ahead.\n                        if (pCount <= 0) {\n                            // Yes, we found the closing parenthesis, create new sub-expression:\n                            if (state === 'within-parentheses') {\n                                expressions.push(new BracketExpression(this._do_parse(tmp)));\n                            } else if (state === 'within-func-parentheses') {\n                                // Function found: create expressions from the inner argument\n                                // string, and create a function expression with it:\n                                let args = this.splitFunctionParams(tmp).map((a) => this._do_parse(a));\n                                expressions.push(new FunctionExpression(funcName, args, this));\n                                funcName = null;\n                            }\n                            state = 'initial';\n                        } else {\n                            pCount--;\n                            tmp += char;\n                        }\n                    } else if (char === '(') {\n                        // begin of a new sub-parenthesis, increase counter:\n                        pCount++;\n                        tmp += char;\n                    } else {\n                        // all other things are just added to the sub-expression:\n                        tmp += char;\n                    }\n                    break;\n            }\n            act++;\n        }\n\n        if (state !== 'initial') {\n            throw new Error('Could not parse formula: Syntax error.');\n        }\n\n        return this.buildExpressionTree(expressions);\n    }\n\n    /**\n     * @see parse(): Builds an expression tree from the given expression array.\n     * Builds a tree with a single root expression in the correct order of operator precedence.\n     *\n     * Note that the given expression objects are modified and linked.\n     *\n     * @param {*} expressions\n     * @return {Expression} The root Expression of the built expression tree\n     */\n    buildExpressionTree(expressions: Expression[]): Expression {\n        if (expressions.length < 1) {\n            throw new Error('No expression given!');\n        }\n        const exprCopy = [...expressions];\n        let idx = 0;\n        let expr = null;\n        // Replace all Power expressions with a partial tree:\n        while (idx < exprCopy.length) {\n            expr = exprCopy[idx];\n            if (expr instanceof PowerExpression) {\n                if (idx === 0 || idx === exprCopy.length - 1) {\n                    throw new Error('Wrong operator position!');\n                }\n                expr.base = exprCopy[idx - 1];\n                expr.exponent = exprCopy[idx + 1];\n                exprCopy[idx - 1] = expr;\n                exprCopy.splice(idx, 2);\n            } else {\n                idx++;\n            }\n        }\n\n        // Replace all Mult/Div expressions with a partial tree:\n        idx = 0;\n        expr = null;\n        while (idx < exprCopy.length) {\n            expr = exprCopy[idx];\n            if (expr instanceof MultDivExpression) {\n                if (idx === 0 || idx === exprCopy.length - 1) {\n                    throw new Error('Wrong operator position!');\n                }\n                expr.left = exprCopy[idx - 1];\n                expr.right = exprCopy[idx + 1];\n                exprCopy[idx - 1] = expr;\n                exprCopy.splice(idx, 2);\n            } else {\n                idx++;\n            }\n        }\n\n        // Replace all Plus/Minus expressions with a partial tree:\n        idx = 0;\n        expr = null;\n        while (idx < exprCopy.length) {\n            expr = exprCopy[idx];\n            if (expr instanceof PlusMinusExpression) {\n                if (idx === 0 || idx === exprCopy.length - 1) {\n                    throw new Error('Wrong operator position!');\n                }\n                expr.left = exprCopy[idx - 1];\n                expr.right = exprCopy[idx + 1];\n                exprCopy[idx - 1] = expr;\n                exprCopy.splice(idx, 2);\n            } else {\n                idx++;\n            }\n        }\n        if (exprCopy.length !== 1) {\n            throw new Error('Could not parse formula: incorrect syntax?');\n        }\n        return exprCopy[0];\n    }\n\n    isOperator(char: string | null) {\n        return typeof char === 'string' && char.match(/[+\\-*/^]/);\n    }\n\n    isOperatorExpr(expr: Expression) {\n        return (\n            expr instanceof PlusMinusExpression || expr instanceof MultDivExpression || expr instanceof PowerExpression\n        );\n    }\n\n    registerVariable(varName: string) {\n        if (this._variables.indexOf(varName) < 0) {\n            this._variables.push(varName);\n        }\n    }\n\n    getVariables() {\n        return this._variables;\n    }\n\n    /**\n     * Evaluates a Formula by delivering values for the Formula's variables.\n     * E.g. if the formula is '3*x^2 + 2*x + 4', you should call `evaulate` as follows:\n     *\n     * evaluate({x:2}) --> Result: 20\n     *\n     * @param {ValueObject|Array<ValueObject>} valueObj An object containing values for variables and (unknown) functions,\n     *   or an array of such objects: If an array is given, all objects are evaluated and the results\n     *   also returned as array.\n     * @return {Number|Array<Number>} The evaluated result, or an array with results\n     */\n    evaluate(valueObj: ValueObject | ValueObject[]): number | number[] {\n        // resolve multiple value objects recursively:\n        if (valueObj instanceof Array) {\n            return valueObj.map((v) => this.evaluate(v)) as number[];\n        }\n        let expr = this.getExpression();\n        if (!(expr instanceof Expression)) {\n            throw new Error('No expression set: Did you init the object with a Formula?');\n        }\n        if (this.options.memoization) {\n            let res = this.resultFromMemory(valueObj);\n            if (res !== null) {\n                return res;\n            } else {\n                res = expr.evaluate({ ...MATH_CONSTANTS, ...valueObj });\n                this.storeInMemory(valueObj, res);\n                return res;\n            }\n        }\n        return expr.evaluate({ ...MATH_CONSTANTS, ...valueObj });\n    }\n\n    hashValues(valueObj: ValueObject) {\n        return JSON.stringify(valueObj);\n    }\n\n    resultFromMemory(valueObj: ValueObject): number | null {\n        let key = this.hashValues(valueObj);\n        let res = this._memory[key];\n        if (res !== undefined) {\n            return res;\n        } else {\n            return null;\n        }\n    }\n\n    storeInMemory(valueObj: ValueObject, value: number) {\n        this._memory[this.hashValues(valueObj)] = value;\n    }\n\n    getExpression() {\n        return this.formulaExpression;\n    }\n\n    getExpressionString() {\n        return this.formulaExpression ? this.formulaExpression.toString() : '';\n    }\n\n    static calc(formula: string, valueObj: ValueObject | null = null, options = {}) {\n        valueObj = valueObj ?? {};\n        return new Formula(formula, options).evaluate(valueObj);\n    }\n}\n"],"names":["MATH_CONSTANTS","Expression","operator","left","right","PowerExpression","MultDivExpression","PlusMinusExpression","params","BracketExpression","expr","__publicField","ValueExpression","value","base","exponent","FunctionExpression","fn","argumentExpressions","formulaObject","paramValues","a","getProperty","e","objFn","_a","mathFn","Formula","object","path","fullPath","curr","propName","VariableExpression","formulaObj","_Formula","fStr","options","formulaString","toSplit","pCount","paramStr","chr","s","c","str","lastChar","act","state","expressions","char","tmp","funcName","args","exprCopy","idx","varName","valueObj","v","res","key","formula","prop"],"mappings":"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"}