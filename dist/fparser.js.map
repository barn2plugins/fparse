{"version":3,"file":"fparser.js","mappings":"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","sources":["webpack://Formula/webpack/universalModuleDefinition","webpack://Formula/./src/fparser.js","webpack://Formula/webpack/bootstrap","webpack://Formula/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Formula\"] = factory();\n\telse\n\t\troot[\"Formula\"] = factory();\n})(this, () => {\nreturn ","/**\n * JS Formula Parser\n * -------------------\n * (c) 2012-2021 Alexander Schenkel, alex@alexi.ch\n *\n * JS Formula Parser takes a string, parses its mathmatical formula\n * and creates an evaluatable Formula object of it.\n *\n * Example input:\n *\n * var fObj = new Formula('sin(PI*x)/(2*PI)');\n * var result = fObj.evaluate({x: 2});\n * var results = fObj.evaluate([\n *     {x: 2},\n *     {x: 4},\n *     {x: 8}\n * ]);\n *\n * LICENSE:\n * -------------\n * MIT license, see LICENSE file\n */\nconst MATH_CONSTANTS = {\n    PI: Math.PI,\n    E: Math.E,\n    LN2: Math.LN2,\n    LN10: Math.LN10,\n    LOG2E: Math.LOG2E,\n    LOG10E: Math.LOG10E,\n    SQRT1_2: Math.SQRT1_2,\n    SQRT2: Math.SQRT2\n};\nexport default class Formula {\n    /**\n     * Creates a new Formula instance\n     *\n     * Optional configuration can be set in the options object:\n     *\n     * - memoization (bool): If true, results are stored and re-used when evaluate() is called with the same parameters\n     *\n     * @param {String} fStr The formula string, e.g. 'sin(x)/cos(y)'\n     * @param {Object} options An options object. Supported options:\n     *    - memoization (bool): If true, results are stored and re-used when evaluate() is called with the same parameters\n     * @param {Formula} parentFormula Internally used to build a Formula AST\n     */\n    constructor(fStr, options = {}) {\n        this.formulaExpression = null;\n        this.options = Object.assign(\n            {\n                memoization: false\n            },\n            options\n        );\n        this._variables = [];\n        this._memory = {};\n        this.setFormula(fStr);\n        return this;\n    }\n\n    /**\n     * Re-sets the given String and parses it to a formula expression. Can be used after initialization,\n     * to re-use the Formula object.\n     *\n     * @param {String} formulaString The formula string to set/parse\n     * @return {this} The Formula object (this)\n     */\n    setFormula(formulaString) {\n        if (formulaString) {\n            this.formulaExpression = null;\n            this._variables = [];\n            this._memory = {};\n            this.formulaStr = formulaString;\n            this.formulaExpression = this.parse(formulaString);\n        }\n        return this;\n    }\n\n    /**\n     * Enable memoization: An expression is only evaluated once for the same input.\n     * Further evaluations with the same input will return the in-memory stored result.\n     */\n    enableMemoization() {\n        this.options.memoization = true;\n    }\n\n    /**\n     * Disable in-memory memoization: each call to evaluate() is executed from scratch.\n     */\n    disableMemoization() {\n        this.options.memoization = false;\n        this._memory = {};\n    }\n\n    /**\n     * Splits the given string by ',', makes sure the ',' is not within\n     * a sub-expression\n     * e.g.: str = \"x,pow(3,4)\" returns 2 elements: x and pow(3,4).\n     */\n    splitFunctionParams(toSplit) {\n        // do not split on ',' within matching brackets.\n        let pCount = 0,\n            paramStr = '';\n        const params = [];\n        for (let chr of toSplit.split('')) {\n            if (chr === ',' && pCount === 0) {\n                // Found function param, save 'em\n                params.push(paramStr);\n                paramStr = '';\n            } else if (chr === '(') {\n                pCount++;\n                paramStr += chr;\n            } else if (chr === ')') {\n                pCount--;\n                paramStr += chr;\n                if (pCount < 0) {\n                    throw new Error('ERROR: Too many closing parentheses!');\n                }\n            } else {\n                paramStr += chr;\n            }\n        }\n        if (pCount !== 0) {\n            throw new Error('ERROR: Too many opening parentheses!');\n        }\n        if (paramStr.length > 0) {\n            params.push(paramStr);\n        }\n        return params;\n    }\n\n    /**\n     * Cleans the input string from unnecessary whitespace,\n     * and replaces some known constants:\n     */\n    cleanupInputString(s) {\n        s = s.replace(/[\\s]+/g, '');\n        // surround known math constants with [], to parse them as named variables [xxx]:\n        Object.keys(MATH_CONSTANTS).forEach((c) => {\n            s = s.replace(new RegExp(`\\\\b${c}\\\\b`, 'g'), `[${c}]`);\n        });\n        return s;\n    }\n\n    /**\n     * Parses the given formula string by using a state machine into a single Expression object,\n     * which represents an expression tree (aka AST).\n     *\n     * First, we split the string into 'expression': An expression can be:\n     *   - a number, e.g. '3.45'\n     *   - an unknown variable, e.g. 'x'\n     *   - a single char operator, such as '*','+' etc...\n     *   - a named variable, in [], e.g. [myvar]\n     *   - a function, such as sin(x)\n     *   - a parenthessed expression, containing other expressions\n     *\n     * We want to create an expression tree out of the string. This is done in 2 stages:\n     * 1. form single expressions from the string: parse the string into known expression objects:\n     *   - numbers/variables\n     *   - operators\n     *   - braces (with a sub-expression)\n     *   - functions (with sub-expressions (aka argument expressions))\n     *   This will lead to an array of expressions.\n     *  As an example:\n     *  \"2 + 3 * (4 + 3 ^ 5) * sin(PI * x)\" forms an array of the following expressions:\n     *  `[2, +, 3, *, bracketExpr(4,+,3,^,5), * , functionExpr(PI,*,x)]`\n     * 2. From the raw expression array we form an expression tree by evaluating the expressions in the correct order:\n     *    e.g.:\n     *  the expression array `[2, +, 3, *, bracketExpr(4,+,3,^,5), * , functionExpr(PI,*,x)]` will be transformed into the expression tree:\n     *  ```\n     *         root expr:  (+)\n     *                     / \\\n     *                    2    (*)\n     *                        / \\\n     *                     (*)  functionExpr(...)\n     *                     / \\\n     *                    3   (bracket(..))\n     * ```\n     *\n     * In the end, we have a single root expression node, which then can be evaluated in the evaluate() function.\n     *\n     * @param {String} str The formula string, e.g. '3*sin(PI/x)'\n     * @returns {Expression} An expression object, representing the expression tree\n     */\n    parse(str) {\n        // clean the input string first. spaces, math constant replacements etc.:\n        str = this.cleanupInputString(str);\n        // start recursive call to parse:\n        return this._do_parse(str);\n    }\n\n    /**\n     * @see parse(): this is the recursive parse function, without the clean string part.\n     * @param {String} str\n     * @returns {Expression} An expression object, representing the expression tree\n     */\n    _do_parse(str) {\n        let lastChar = str.length - 1,\n            act = 0,\n            state = 0,\n            expressions = [],\n            char = '',\n            tmp = '',\n            funcName = null,\n            pCount = 0;\n\n        while (act <= lastChar) {\n            switch (state) {\n                case 0:\n                    // None state, the beginning. Read a char and see what happens.\n                    char = str.charAt(act);\n                    if (char.match(/[0-9.]/)) {\n                        // found the beginning of a number, change state to \"within-number\"\n                        state = 'within-nr';\n                        tmp = '';\n                        act--;\n                    } else if (this.isOperator(char)) {\n                        // Simple operators. Note: '-' must be treaten specially,\n                        // it could be part of a number.\n                        // it MUST be part of a number if the last found expression\n                        // was an operator (or the beginning):\n                        if (char === '-') {\n                            if (expressions.length === 0 || this.isOperatorExpr(expressions[expressions.length - 1])) {\n                                state = 'within-nr';\n                                tmp = '-';\n                                break;\n                            }\n                        }\n\n                        // Found a simple operator, store as expression:\n                        if (act === lastChar || this.isOperatorExpr(expressions[expressions.length - 1])) {\n                            state = -1; // invalid to end with an operator, or have 2 operators in conjunction\n                            break;\n                        } else {\n                            expressions.push(Expression.createOperatorExpression(char));\n                            state = 0;\n                        }\n                    } else if (char === '(') {\n                        // left parenthes found, seems to be the beginning of a new sub-expression:\n                        state = 'within-parentheses';\n                        tmp = '';\n                        pCount = 0;\n                    } else if (char === '[') {\n                        // left named var separator char found, seems to be the beginning of a named var:\n                        state = 'within-named-var';\n                        tmp = '';\n                    } else if (char.match(/[a-zA-Z]/)) {\n                        // multiple chars means it may be a function, else its a var which counts as own expression:\n                        if (act < lastChar && str.charAt(act + 1).match(/[a-zA-Z0-9_]/)) {\n                            tmp = char;\n                            state = 'within-func';\n                        } else {\n                            // Single variable found:\n                            // We need to check some special considerations:\n                            // - If the last char was a number (e.g. 3x), we need to create a multiplication out of it (3*x)\n                            if (\n                                expressions.length > 0 &&\n                                expressions[expressions.length - 1] instanceof ValueExpression\n                            ) {\n                                expressions.push(Expression.createOperatorExpression('*'));\n                            }\n                            expressions.push(new VariableExpression(char));\n                            this.registerVariable(char);\n                            state = 0;\n                            tmp = '';\n                        }\n                    }\n                    break;\n                case 'within-nr':\n                    char = str.charAt(act);\n                    if (char.match(/[0-9.]/)) {\n                        //Still within number, store and continue\n                        tmp += char;\n                        if (act === lastChar) {\n                            expressions.push(new ValueExpression(tmp));\n                            state = 0;\n                        }\n                    } else {\n                        // Number finished on last round, so add as expression:\n                        if (tmp === '-') {\n                            // just a single '-' means: a variable could follow (e.g. like in 3*-x), we convert it to -1: (3*-1x)\n                            tmp = -1;\n                        }\n                        expressions.push(new ValueExpression(tmp));\n                        tmp = '';\n                        state = 0;\n                        act--;\n                    }\n                    break;\n\n                case 'within-func':\n                    char = str.charAt(act);\n                    if (char.match(/[a-zA-Z0-9_]/)) {\n                        tmp += char;\n                    } else if (char === '(') {\n                        funcName = tmp;\n                        tmp = '';\n                        pCount = 0;\n                        state = 'within-func-parentheses';\n                    } else {\n                        throw new Error('Wrong character for function at position ' + act);\n                    }\n\n                    break;\n\n                case 'within-named-var':\n                    char = str.charAt(act);\n                    if (char === ']') {\n                        // end of named var, create expression:\n                        expressions.push(new VariableExpression(tmp));\n                        this.registerVariable(tmp);\n                        tmp = '';\n                        state = 0;\n                    } else if (char.match(/[a-zA-Z0-9_.]/)) {\n                        tmp += char;\n                    } else {\n                        throw new Error('Character not allowed within named variable: ' + char);\n                    }\n                    break;\n\n                case 'within-parentheses':\n                case 'within-func-parentheses':\n                    char = str.charAt(act);\n                    if (char === ')') {\n                        //Check if this is the matching closing parenthesis.If not, just read ahead.\n                        if (pCount <= 0) {\n                            // Yes, we found the closing parenthesis, create new sub-expression:\n                            if (state === 'within-parentheses') {\n                                expressions.push(new BracketExpression(this._do_parse(tmp)));\n                            } else if (state === 'within-func-parentheses') {\n                                // Function found: create expressions from the inner argument\n                                // string, and create a function expression with it:\n                                let args = this.splitFunctionParams(tmp).map((a) => this._do_parse(a));\n                                expressions.push(new FunctionExpression(funcName, args, this));\n                                funcName = null;\n                            }\n                            state = 0;\n                        } else {\n                            pCount--;\n                            tmp += char;\n                        }\n                    } else if (char === '(') {\n                        // begin of a new sub-parenthesis, increase counter:\n                        pCount++;\n                        tmp += char;\n                    } else {\n                        // all other things are just added to the sub-expression:\n                        tmp += char;\n                    }\n                    break;\n            }\n            act++;\n        }\n\n        if (state !== 0) {\n            throw new Error('Could not parse formula: Syntax error.');\n        }\n\n        return this.buildExpressionTree(expressions);\n    }\n\n    /**\n     * @see parse(): Builds an expression tree from the given expression array.\n     * Builds a tree with a single root expression in the correct order of operator precedence.\n     *\n     * Note that the given expression objects are modified and linked.\n     *\n     * @param {*} expressions\n     * @return {Expression} The root Expression of the built expression tree\n     */\n    buildExpressionTree(expressions) {\n        if (expressions.length < 1) {\n            return null;\n        }\n        const exprCopy = [...expressions];\n        let idx = 0;\n        let expr = null;\n        // Replace all Power expressions with a partial tree:\n        while (idx < exprCopy.length) {\n            expr = exprCopy[idx];\n            if (expr instanceof PowerExpression) {\n                if (idx === 0 || idx === exprCopy.length - 1) {\n                    throw new Error('Wrong operator position!');\n                }\n                expr.base = exprCopy[idx - 1];\n                expr.exponent = exprCopy[idx + 1];\n                exprCopy[idx - 1] = expr;\n                exprCopy.splice(idx, 2);\n            } else {\n                idx++;\n            }\n        }\n\n        // Replace all Mult/Div expressions with a partial tree:\n        idx = 0;\n        expr = null;\n        while (idx < exprCopy.length) {\n            expr = exprCopy[idx];\n            if (expr instanceof MultDivExpression) {\n                if (idx === 0 || idx === exprCopy.length - 1) {\n                    throw new Error('Wrong operator position!');\n                }\n                expr.left = exprCopy[idx - 1];\n                expr.right = exprCopy[idx + 1];\n                exprCopy[idx - 1] = expr;\n                exprCopy.splice(idx, 2);\n            } else {\n                idx++;\n            }\n        }\n\n        // Replace all Plus/Minus expressions with a partial tree:\n        idx = 0;\n        expr = null;\n        while (idx < exprCopy.length) {\n            expr = exprCopy[idx];\n            if (expr instanceof PlusMinusExpression) {\n                if (idx === 0 || idx === exprCopy.length - 1) {\n                    throw new Error('Wrong operator position!');\n                }\n                expr.left = exprCopy[idx - 1];\n                expr.right = exprCopy[idx + 1];\n                exprCopy[idx - 1] = expr;\n                exprCopy.splice(idx, 2);\n            } else {\n                idx++;\n            }\n        }\n        if (exprCopy.length !== 1) {\n            throw new Error('Could not parse formula: incorrect syntax?');\n        }\n        return exprCopy[0];\n    }\n\n    isOperator(char) {\n        return typeof char === 'string' && char.match(/[\\+\\-\\*\\/\\^]/);\n    }\n\n    isOperatorExpr(expr) {\n        return (\n            expr instanceof PlusMinusExpression || expr instanceof MultDivExpression || expr instanceof PowerExpression\n        );\n    }\n\n    registerVariable(varName) {\n        if (this._variables.indexOf(varName) < 0) {\n            this._variables.push(varName);\n        }\n    }\n\n    getVariables() {\n        return this._variables;\n    }\n\n    /**\n     * Evaluates a Formula by delivering values for the Formula's variables.\n     * E.g. if the formula is '3*x^2 + 2*x + 4', you should call `evaulate` as follows:\n     *\n     * evaluate({x:2}) --> Result: 20\n     *\n     * @param {Object|Array} valueObj An object containing values for variables and (unknown) functions,\n     *   or an array of such objects: If an array is given, all objects are evaluated and the results\n     *   also returned as array.\n     * @return {Number|Array} The evaluated result, or an array with results\n     */\n    evaluate(valueObj) {\n        // resolve multiple value objects recursively:\n        if (valueObj instanceof Array) {\n            return valueObj.map((v) => this.evaluate(v));\n        }\n        let expr = this.getExpression();\n        if (!(expr instanceof Expression)) {\n            throw new Error('No expression set: Did you init the object with a Formula?');\n        }\n        if (this.options.memoization) {\n            let res = this.resultFromMemory(valueObj);\n            if (res !== null) {\n                return res;\n            } else {\n                res = expr.evaluate({ ...MATH_CONSTANTS, ...valueObj });\n                this.storeInMemory(valueObj, res);\n                return res;\n            }\n        }\n        return expr.evaluate({ ...MATH_CONSTANTS, ...valueObj });\n    }\n\n    hashValues(valueObj) {\n        return JSON.stringify(valueObj);\n    }\n\n    resultFromMemory(valueObj) {\n        let key = this.hashValues(valueObj);\n        let res = this._memory[key];\n        if (res !== undefined) {\n            return res;\n        } else {\n            return null;\n        }\n    }\n\n    storeInMemory(valueObj, value) {\n        this._memory[this.hashValues(valueObj)] = value;\n    }\n\n    getExpression() {\n        return this.formulaExpression;\n    }\n\n    getExpressionString() {\n        return this.formulaExpression ? this.formulaExpression.toString() : '';\n    }\n\n    static calc(formula, valueObj, options = {}) {\n        valueObj = valueObj || {};\n        return new Formula(formula, options).evaluate(valueObj);\n    }\n}\n\nclass Expression {\n    static createOperatorExpression(operator, left = null, right = null) {\n        if (operator === '^') {\n            return new PowerExpression(operator, left, right);\n        }\n        if (operator === '*' || operator === '/') {\n            return new MultDivExpression(operator, left, right);\n        }\n        if (operator === '+' || operator === '-') {\n            return new PlusMinusExpression(operator, left, right);\n        }\n        throw new Error(`Unknown operator: ${operator}`);\n    }\n\n    evaluate(params = {}) {\n        throw new Error('Must be defined in child classes');\n    }\n\n    toString() {\n        return '';\n    }\n}\n\nclass BracketExpression extends Expression {\n    constructor(expr) {\n        super();\n        this.innerExpression = expr;\n        if (!(this.innerExpression instanceof Expression)) {\n            throw new Error('No inner expression given for bracket expression');\n        }\n    }\n    evaluate(params = {}) {\n        return this.innerExpression.evaluate(params);\n    }\n    toString() {\n        return `(${this.innerExpression.toString()})`;\n    }\n}\n\nclass ValueExpression extends Expression {\n    constructor(value) {\n        super();\n        this.value = Number(value);\n        if (isNaN(this.value)) {\n            throw new Error('Cannot parse number: ' + value);\n        }\n    }\n    evaluate(params = {}) {\n        return this.value;\n    }\n    toString() {\n        return String(this.value);\n    }\n}\n\nclass PlusMinusExpression extends Expression {\n    constructor(operator, left = null, right = null) {\n        super();\n        if (!['+', '-'].includes(operator)) {\n            throw new Error(`Operator not allowed in Plus/Minus expression: ${operator}`);\n        }\n        this.operator = operator;\n        this.left = left;\n        this.right = right;\n    }\n\n    evaluate(params = {}) {\n        if (this.operator === '+') {\n            return this.left.evaluate(params) + this.right.evaluate(params);\n        }\n        if (this.operator === '-') {\n            return this.left.evaluate(params) - this.right.evaluate(params);\n        }\n        throw new Error('Unknown operator for PlusMinus expression');\n    }\n\n    toString() {\n        return `${this.left.toString()} ${this.operator} ${this.right.toString()}`;\n    }\n}\n\nclass MultDivExpression extends Expression {\n    constructor(operator, left = null, right = null) {\n        super();\n        if (!['*', '/'].includes(operator)) {\n            throw new Error(`Operator not allowed in Multiply/Division expression: ${operator}`);\n        }\n        this.operator = operator;\n        this.left = left;\n        this.right = right;\n    }\n\n    evaluate(params = {}) {\n        if (this.operator === '*') {\n            return this.left.evaluate(params) * this.right.evaluate(params);\n        }\n        if (this.operator === '/') {\n            return this.left.evaluate(params) / this.right.evaluate(params);\n        }\n        throw new Error('Unknown operator for MultDiv expression');\n    }\n\n    toString() {\n        return `${this.left.toString()} ${this.operator} ${this.right.toString()}`;\n    }\n}\n\nclass PowerExpression extends Expression {\n    constructor(base = null, exponent = null) {\n        super();\n        this.base = base;\n        this.exponent = exponent;\n    }\n\n    evaluate(params = {}) {\n        return Math.pow(this.base.evaluate(params), this.exponent.evaluate(params));\n    }\n\n    toString() {\n        return `${this.base.toString()}^${this.exponent.toString()}`;\n    }\n}\nclass FunctionExpression extends Expression {\n    constructor(fn, argumentExpressions, formulaObject = null) {\n        super();\n        this.fn = fn;\n        this.argumentExpressions = argumentExpressions || [];\n        this.formulaObject = formulaObject;\n        this.blacklisted = undefined;\n    }\n\n    evaluate(params = {}) {\n        params = params || {};\n        const paramValues = this.argumentExpressions.map((a) => a.evaluate(params));\n\n        // If the params object itself has a function definition with\n        // the function name, call this one:\n        if (params[this.fn] instanceof Function) {\n            return params[this.fn].apply(this, paramValues);\n        }\n        // perhaps the Formula object has the function? so call it:\n        else if (this.formulaObject && this.formulaObject[this.fn] instanceof Function) {\n            // Don't, if it is blacklisted:\n            if (this.isBlacklisted()) {\n                throw new Error('Blacklisted function called: ' + this.fn);\n            }\n            return this.formulaObject[this.fn].apply(this.formulaObject, paramValues);\n        }\n        // Has the JS Math object a function as requested? Call it:\n        else if (Math[this.fn] instanceof Function) {\n            return Math[this.fn].apply(this, paramValues);\n        }\n        // No more options left: sorry!\n        else {\n            throw new Error('Function not found: ' + this.fn);\n        }\n    }\n\n    toString() {\n        return `${this.fn}(${this.argumentExpressions.map((a) => a.toString()).join(', ')})`;\n    }\n\n    isBlacklisted() {\n        // cache evaluation of blacklisted function, to save call time:\n        if (this.blacklisted === undefined) {\n            this.blacklisted = Formula.functionBlacklist.includes(\n                this.formulaObject ? this.formulaObject[this.fn] : null\n            );\n        }\n        return this.blacklisted;\n    }\n}\n\nfunction getProperty(object, path, fullPath) {\n    let curr = object;\n    for (let i = 0; i < path.length; i++) {\n        if (curr[path[i]] === undefined) {\n            throw new Error(`Cannot evaluate ${path[i]}, property not found (from path ${fullPath})`);\n        }\n\n        curr = curr[path[i]];\n    }\n\n    if (typeof curr === 'object') {\n        throw new Error('Invalid value');\n    }\n\n    return curr;\n}\n\nclass VariableExpression extends Expression {\n    constructor(fullPath) {\n        super();\n        this.fullPath = fullPath;\n        this.varPath = fullPath.split('.');\n    }\n\n    evaluate(params = {}) {\n        // params contain variable / value pairs: If this object's variable matches\n        // a varname found in the params, return the value.\n        // eg: params = {x: 5,y:3}, varname = x, return 5\n        return Number(getProperty(params, this.varPath, this.fullPath));\n    }\n    toString() {\n        return `${this.varPath.join('.')}`;\n    }\n}\n\nFormula.Expression = Expression;\nFormula.BracketExpression = BracketExpression;\nFormula.PowerExpression = PowerExpression;\nFormula.MultDivExpression = MultDivExpression;\nFormula.PlusMinusExpression = PlusMinusExpression;\nFormula.ValueExpression = ValueExpression;\nFormula.VariableExpression = VariableExpression;\nFormula.FunctionExpression = FunctionExpression;\nFormula.MATH_CONSTANTS = MATH_CONSTANTS;\n\n// Create a function blacklist:\nFormula.functionBlacklist = Object.getOwnPropertyNames(Formula.prototype)\n    .filter((prop) => Formula.prototype[prop] instanceof Function)\n    .map((prop) => Formula.prototype[prop]);\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(91);\n"],"names":["root","factory","exports","module","define","amd","this","MATH_CONSTANTS","PI","Math","E","LN2","LN10","LOG2E","LOG10E","SQRT1_2","SQRT2","Formula","fStr","options","arguments","length","undefined","_classCallCheck","formulaExpression","Object","assign","memoization","_variables","_memory","setFormula","_createClass","key","value","formulaString","formulaStr","parse","toSplit","_step","pCount","paramStr","params","_iterator","_createForOfIteratorHelper","split","s","n","done","chr","push","Error","err","e","f","replace","keys","forEach","c","RegExp","concat","str","cleanupInputString","_do_parse","_this","lastChar","act","state","expressions","char","tmp","funcName","charAt","match","isOperator","isOperatorExpr","Expression","createOperatorExpression","ValueExpression","VariableExpression","registerVariable","BracketExpression","args","splitFunctionParams","map","a","FunctionExpression","buildExpressionTree","exprCopy","_toConsumableArray","idx","expr","PowerExpression","base","exponent","splice","MultDivExpression","left","right","PlusMinusExpression","varName","indexOf","valueObj","_this2","Array","v","evaluate","getExpression","res","resultFromMemory","_objectSpread","storeInMemory","JSON","stringify","hashValues","toString","formula","_exports","default","operator","_Expression","_inherits","_super","_createSuper","_this3","call","innerExpression","_Expression2","_super2","_this4","Number","isNaN","String","_Expression3","_super3","_this5","includes","_Expression4","_super4","_this6","_Expression5","_super5","_this7","pow","_Expression6","_super6","fn","argumentExpressions","_this8","formulaObject","blacklisted","paramValues","Function","apply","isBlacklisted","join","functionBlacklist","_Expression7","_super7","fullPath","_this9","varPath","object","path","curr","i","_typeof","getProperty","getOwnPropertyNames","prototype","filter","prop","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__"],"sourceRoot":""}