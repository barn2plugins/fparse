(function(u,o){typeof exports=="object"&&typeof module!="undefined"?module.exports=o():typeof define=="function"&&define.amd?define(o):(u=typeof globalThis!="undefined"?globalThis:u||self,u.Formula=o())})(this,function(){"use strict";var k=Object.defineProperty;var P=(u,o,f)=>o in u?k(u,o,{enumerable:!0,configurable:!0,writable:!0,value:f}):u[o]=f;var n=(u,o,f)=>(P(u,typeof o!="symbol"?o+"":o,f),f);const u={PI:Math.PI,E:Math.E,LN2:Math.LN2,LN10:Math.LN10,LOG2E:Math.LOG2E,LOG10E:Math.LOG10E,SQRT1_2:Math.SQRT1_2,SQRT2:Math.SQRT2};class o{static createOperatorExpression(i,t,e){if(i==="^")return new g(t,e);if(i==="*"||i==="/")return new x(i,t,e);if(i==="+"||i==="-")return new m(i,t,e);throw new Error(`Unknown operator: ${i}`)}evaluate(i={}){throw new Error("Empty Expression - Must be defined in child classes")}toString(){return""}}class f extends o{constructor(t){super();n(this,"innerExpression");if(this.innerExpression=t,!(this.innerExpression instanceof o))throw new Error("No inner expression given for bracket expression")}evaluate(t={}){return this.innerExpression.evaluate(t)}toString(){return`(${this.innerExpression.toString()})`}}class E extends o{constructor(t){super();n(this,"value");if(this.value=Number(t),isNaN(this.value))throw new Error("Cannot parse number: "+t)}evaluate(){return this.value}toString(){return String(this.value)}}class m extends o{constructor(t,e,r){super();n(this,"operator");n(this,"left");n(this,"right");if(!["+","-"].includes(t))throw new Error(`Operator not allowed in Plus/Minus expression: ${t}`);this.operator=t,this.left=e,this.right=r}evaluate(t={}){if(this.operator==="+")return this.left.evaluate(t)+this.right.evaluate(t);if(this.operator==="-")return this.left.evaluate(t)-this.right.evaluate(t);throw new Error("Unknown operator for PlusMinus expression")}toString(){return`${this.left.toString()} ${this.operator} ${this.right.toString()}`}}class x extends o{constructor(t,e,r){super();n(this,"operator");n(this,"left");n(this,"right");if(!["*","/"].includes(t))throw new Error(`Operator not allowed in Multiply/Division expression: ${t}`);this.operator=t,this.left=e,this.right=r}evaluate(t={}){if(this.operator==="*")return this.left.evaluate(t)*this.right.evaluate(t);if(this.operator==="/")return this.left.evaluate(t)/this.right.evaluate(t);throw new Error("Unknown operator for MultDiv expression")}toString(){return`${this.left.toString()} ${this.operator} ${this.right.toString()}`}}class g extends o{constructor(t,e){super();n(this,"base");n(this,"exponent");this.base=t,this.exponent=e}evaluate(t={}){return Math.pow(this.base.evaluate(t),this.exponent.evaluate(t))}toString(){return`${this.base.toString()}^${this.exponent.toString()}`}}class y extends o{constructor(t,e,r=null){super();n(this,"fn");n(this,"varPath");n(this,"argumentExpressions");n(this,"formulaObject");n(this,"blacklisted");this.fn=t!=null?t:"",this.varPath=this.fn.split("."),this.argumentExpressions=e||[],this.formulaObject=r,this.blacklisted=void 0}evaluate(t={}){var a;t=t||{};const e=this.argumentExpressions.map(s=>s.evaluate(t));try{let s=c(t,this.varPath,this.fn);if(s instanceof Function)return s.apply(this,e)}catch(s){}let r;try{r=c((a=this.formulaObject)!=null?a:{},this.varPath,this.fn)}catch(s){}if(this.formulaObject&&r instanceof Function){if(this.isBlacklisted())throw new Error("Blacklisted function called: "+this.fn);return r.apply(this.formulaObject,e)}try{const s=c(Math,this.varPath,this.fn);if(s instanceof Function)return s.apply(this,e)}catch(s){}throw new Error("Function not found: "+this.fn)}toString(){return`${this.fn}(${this.argumentExpressions.map(t=>t.toString()).join(", ")})`}isBlacklisted(){return this.blacklisted===void 0&&(this.blacklisted=d.functionBlacklist.includes(this.formulaObject?this.formulaObject[this.fn]:null)),this.blacklisted}}function c(p,i,t){let e=p;for(let r of i){if(typeof e!="object")throw new Error(`Cannot evaluate ${r}, property not found (from path ${t})`);if(e[r]===void 0)throw new Error(`Cannot evaluate ${r}, property not found (from path ${t})`);e=e[r]}if(typeof e=="object")throw new Error("Invalid value");return e}class v extends o{constructor(t,e=null){super();n(this,"fullPath");n(this,"varPath");n(this,"formulaObject");this.formulaObject=e,this.fullPath=t,this.varPath=t.split(".")}evaluate(t={}){var r;let e;try{e=c(t,this.varPath,this.fullPath)}catch(a){}if(e===void 0&&(e=c((r=this.formulaObject)!=null?r:{},this.varPath,this.fullPath)),typeof e=="function"||typeof e=="object")throw new Error(`Cannot use ${this.fullPath} as value: It contains a non-numerical value.`);return Number(e)}toString(){return`${this.varPath.join(".")}`}}const l=class l{constructor(i,t={}){n(this,"formulaExpression");n(this,"options");n(this,"formulaStr");n(this,"_variables");n(this,"_memory");this.formulaExpression=null,this.options={memoization:!1,...t},this.formulaStr="",this._variables=[],this._memory={},this.setFormula(i)}setFormula(i){return i&&(this.formulaExpression=null,this._variables=[],this._memory={},this.formulaStr=i,this.formulaExpression=this.parse(i)),this}enableMemoization(){this.options.memoization=!0}disableMemoization(){this.options.memoization=!1,this._memory={}}splitFunctionParams(i){let t=0,e="";const r=[];for(let a of i.split(""))if(a===","&&t===0)r.push(e),e="";else if(a==="(")t++,e+=a;else if(a===")"){if(t--,e+=a,t<0)throw new Error("ERROR: Too many closing parentheses!")}else e+=a;if(t!==0)throw new Error("ERROR: Too many opening parentheses!");return e.length>0&&r.push(e),r}cleanupInputString(i){return i=i.replace(/\s+/g,""),Object.keys(u).forEach(t=>{i=i.replace(new RegExp(`\\b${t}\\b`,"g"),`[${t}]`)}),i}parse(i){return i=this.cleanupInputString(i),this._do_parse(i)}_do_parse(i){let t=i.length-1,e=0,r="initial",a=[],s="",h="",b=null,w=0;for(;e<=t;){switch(r){case"initial":if(s=i.charAt(e),s.match(/[0-9.]/))r="within-nr",h="",e--;else if(this.isOperator(s)){if(s==="-"&&(a.length===0||this.isOperatorExpr(a[a.length-1]))){r="within-nr",h="-";break}if(e===t||this.isOperatorExpr(a[a.length-1])){r="invalid";break}else a.push(o.createOperatorExpression(s,new o,new o)),r="initial"}else s==="("?(r="within-parentheses",h="",w=0):s==="["?(r="within-named-var",h=""):s.match(/[a-zA-Z]/)&&(e<t&&i.charAt(e+1).match(/[a-zA-Z0-9_.]/)?(h=s,r="within-func"):(a.length>0&&a[a.length-1]instanceof E&&a.push(o.createOperatorExpression("*",new o,new o)),a.push(new v(s,this)),this.registerVariable(s),r="initial",h=""));break;case"within-nr":s=i.charAt(e),s.match(/[0-9.]/)?(h+=s,e===t&&(a.push(new E(h)),r="initial")):(h==="-"&&(h="-1"),a.push(new E(h)),h="",r="initial",e--);break;case"within-func":if(s=i.charAt(e),s.match(/[a-zA-Z0-9_.]/))h+=s;else if(s==="(")b=h,h="",w=0,r="within-func-parentheses";else throw new Error("Wrong character for function at position "+e);break;case"within-named-var":if(s=i.charAt(e),s==="]")a.push(new v(h,this)),this.registerVariable(h),h="",r="initial";else if(s.match(/[a-zA-Z0-9_.]/))h+=s;else throw new Error("Character not allowed within named variable: "+s);break;case"within-parentheses":case"within-func-parentheses":if(s=i.charAt(e),s===")")if(w<=0){if(r==="within-parentheses")a.push(new f(this._do_parse(h)));else if(r==="within-func-parentheses"){let S=this.splitFunctionParams(h).map(M=>this._do_parse(M));a.push(new y(b,S,this)),b=null}r="initial"}else w--,h+=s;else s==="("&&w++,h+=s;break}e++}if(r!=="initial")throw new Error("Could not parse formula: Syntax error.");return this.buildExpressionTree(a)}buildExpressionTree(i){if(i.length<1)throw new Error("No expression given!");const t=[...i];let e=0,r=null;for(;e<t.length;)if(r=t[e],r instanceof g){if(e===0||e===t.length-1)throw new Error("Wrong operator position!");r.base=t[e-1],r.exponent=t[e+1],t[e-1]=r,t.splice(e,2)}else e++;for(e=0,r=null;e<t.length;)if(r=t[e],r instanceof x){if(e===0||e===t.length-1)throw new Error("Wrong operator position!");r.left=t[e-1],r.right=t[e+1],t[e-1]=r,t.splice(e,2)}else e++;for(e=0,r=null;e<t.length;)if(r=t[e],r instanceof m){if(e===0||e===t.length-1)throw new Error("Wrong operator position!");r.left=t[e-1],r.right=t[e+1],t[e-1]=r,t.splice(e,2)}else e++;if(t.length!==1)throw new Error("Could not parse formula: incorrect syntax?");return t[0]}isOperator(i){return typeof i=="string"&&i.match(/[+\-*/^]/)}isOperatorExpr(i){return i instanceof m||i instanceof x||i instanceof g}registerVariable(i){this._variables.indexOf(i)<0&&this._variables.push(i)}getVariables(){return this._variables}evaluate(i){if(i instanceof Array)return i.map(e=>this.evaluate(e));let t=this.getExpression();if(!(t instanceof o))throw new Error("No expression set: Did you init the object with a Formula?");if(this.options.memoization){let e=this.resultFromMemory(i);return e!==null||(e=t.evaluate({...u,...i}),this.storeInMemory(i,e)),e}return t.evaluate({...u,...i})}hashValues(i){return JSON.stringify(i)}resultFromMemory(i){let t=this.hashValues(i),e=this._memory[t];return e!==void 0?e:null}storeInMemory(i,t){this._memory[this.hashValues(i)]=t}getExpression(){return this.formulaExpression}getExpressionString(){return this.formulaExpression?this.formulaExpression.toString():""}static calc(i,t=null,e={}){return t=t!=null?t:{},new l(i,e).evaluate(t)}};n(l,"Expression",o),n(l,"BracketExpression",f),n(l,"PowerExpression",g),n(l,"MultDivExpression",x),n(l,"PlusMinusExpression",m),n(l,"ValueExpression",E),n(l,"VariableExpression",v),n(l,"FunctionExpression",y),n(l,"MATH_CONSTANTS",u),n(l,"functionBlacklist",Object.getOwnPropertyNames(l.prototype).filter(i=>l.prototype[i]instanceof Function).map(i=>l.prototype[i]));let d=l;return d});
//# sourceMappingURL=fparser.umd.cjs.map
