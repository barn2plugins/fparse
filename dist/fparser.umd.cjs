(function(c,h){typeof exports=="object"&&typeof module!="undefined"?module.exports=h():typeof define=="function"&&define.amd?define(h):(c=typeof globalThis!="undefined"?globalThis:c||self,c.Formula=h())})(this,function(){"use strict";var O=Object.defineProperty;var $=(c,h,p)=>h in c?O(c,h,{enumerable:!0,configurable:!0,writable:!0,value:p}):c[h]=p;var n=(c,h,p)=>($(c,typeof h!="symbol"?h+"":h,p),p);const c={PI:Math.PI,E:Math.E,LN2:Math.LN2,LN10:Math.LN10,LOG2E:Math.LOG2E,LOG10E:Math.LOG10E,SQRT1_2:Math.SQRT1_2,SQRT2:Math.SQRT2};class h{static throwIfNotNumber(r){const e=typeof r;if(e!=="number")throw new Error("Math operators required type of number: given is "+e)}}class p{static throwIfNotNumber(r){const e=typeof r;if(e!=="number")throw new Error("Math functions required type of number: given is "+e)}}class l{static createOperatorExpression(r,e,t){if(r==="^")return new d(e,t);if(r==="*"||r==="/")return new x(r,e,t);if(r==="+"||r==="-")return new b(r,e,t);throw new Error(`Unknown operator: ${r}`)}evaluate(r={}){throw new Error("Empty Expression - Must be defined in child classes")}toString(){return""}}class S extends l{constructor(e){super();n(this,"innerExpression");if(this.innerExpression=e,!(this.innerExpression instanceof l))throw new Error("No inner expression given for bracket expression")}evaluate(e={}){return this.innerExpression.evaluate(e)}toString(){return`(${this.innerExpression.toString()})`}}class m extends l{constructor(e,t="number"){super();n(this,"value");n(this,"type");switch(this.value=Number(e),t){case"number":if(this.value=Number(e),isNaN(this.value))throw new Error("Cannot parse number: "+e);break;case"string":this.value=String(e);break;default:throw new Error("Invalid value type: "+t)}this.type=t}evaluate(){return this.value}toString(){switch(this.type){case"number":return String(this.value);case"string":return'"'+this.value+'"';default:throw new Error("Invalid type")}}}class b extends l{constructor(e,t,i){super();n(this,"operator");n(this,"left");n(this,"right");if(!["+","-"].includes(e))throw new Error(`Operator not allowed in Plus/Minus expression: ${e}`);this.operator=e,this.left=t,this.right=i}evaluate(e={}){const t=Number(this.left.evaluate(e)),i=Number(this.right.evaluate(e));if(h.throwIfNotNumber(t),h.throwIfNotNumber(i),this.operator==="+")return t+i;if(this.operator==="-")return t-i;throw new Error("Unknown operator for PlusMinus expression")}toString(){return`${this.left.toString()} ${this.operator} ${this.right.toString()}`}}class x extends l{constructor(e,t,i){super();n(this,"operator");n(this,"left");n(this,"right");if(!["*","/"].includes(e))throw new Error(`Operator not allowed in Multiply/Division expression: ${e}`);this.operator=e,this.left=t,this.right=i}evaluate(e={}){const t=Number(this.left.evaluate(e)),i=Number(this.right.evaluate(e));if(h.throwIfNotNumber(t),h.throwIfNotNumber(i),this.operator==="*")return t*i;if(this.operator==="/")return t/i;throw new Error("Unknown operator for MultDiv expression")}toString(){return`${this.left.toString()} ${this.operator} ${this.right.toString()}`}}class d extends l{constructor(e,t){super();n(this,"base");n(this,"exponent");this.base=e,this.exponent=t}evaluate(e={}){const t=Number(this.base.evaluate(e)),i=Number(this.exponent.evaluate(e));return h.throwIfNotNumber(t),h.throwIfNotNumber(i),Math.pow(t,i)}toString(){return`${this.base.toString()}^${this.exponent.toString()}`}}class M extends l{constructor(e,t,i=null){super();n(this,"fn");n(this,"varPath");n(this,"argumentExpressions");n(this,"formulaObject");n(this,"blacklisted");this.fn=e!=null?e:"",this.varPath=this.fn.split("."),this.argumentExpressions=t||[],this.formulaObject=i,this.blacklisted=void 0}evaluate(e={}){var a;e=e||{};const t=this.argumentExpressions.map(s=>s.evaluate(e));try{let s=E(e,this.varPath,this.fn);if(s instanceof Function)return s.apply(this,t)}catch(s){}let i;try{i=E((a=this.formulaObject)!=null?a:{},this.varPath,this.fn)}catch(s){}if(this.formulaObject&&i instanceof Function){if(this.isBlacklisted())throw new Error("Blacklisted function called: "+this.fn);return i.apply(this.formulaObject,t)}try{const s=E(Math,this.varPath,this.fn);if(s instanceof Function)return t.forEach(o=>{p.throwIfNotNumber(o)}),s.apply(this,t)}catch(s){}throw new Error("Function not found: "+this.fn)}toString(){return`${this.fn}(${this.argumentExpressions.map(e=>e.toString()).join(", ")})`}isBlacklisted(){return this.blacklisted===void 0&&(this.blacklisted=v.functionBlacklist.includes(this.formulaObject?this.formulaObject[this.fn]:null)),this.blacklisted}}function E(f,r,e){let t=f;for(let i of r){if(typeof t!="object")throw new Error(`Cannot evaluate ${i}, property not found (from path ${e})`);if(t[i]===void 0)throw new Error(`Cannot evaluate ${i}, property not found (from path ${e})`);t=t[i]}if(typeof t=="object")throw new Error("Invalid value");return t}class y extends l{constructor(e,t=null){super();n(this,"fullPath");n(this,"varPath");n(this,"formulaObject");this.formulaObject=t,this.fullPath=e,this.varPath=e.split(".")}evaluate(e={}){var i;let t;try{t=E(e,this.varPath,this.fullPath)}catch(a){}if(t===void 0&&(t=E((i=this.formulaObject)!=null?i:{},this.varPath,this.fullPath)),typeof t=="function"||typeof t=="object")throw new Error(`Cannot use ${this.fullPath} as value: It contains a non-numerical value.`);return t}toString(){return`${this.varPath.join(".")}`}}const u=class u{constructor(r,e={}){n(this,"formulaExpression");n(this,"options");n(this,"formulaStr");n(this,"_variables");n(this,"_memory");this.formulaExpression=null,this.options={memoization:!1,...e},this.formulaStr="",this._variables=[],this._memory={},this.setFormula(r)}setFormula(r){return r&&(this.formulaExpression=null,this._variables=[],this._memory={},this.formulaStr=r,this.formulaExpression=this.parse(r)),this}enableMemoization(){this.options.memoization=!0}disableMemoization(){this.options.memoization=!1,this._memory={}}splitFunctionParams(r){let e=0,t="";const i=[];for(let a of r.split(""))if(a===","&&e===0)i.push(t),t="";else if(a==="(")e++,t+=a;else if(a===")"){if(e--,t+=a,e<0)throw new Error("ERROR: Too many closing parentheses!")}else t+=a;if(e!==0)throw new Error("ERROR: Too many opening parentheses!");return t.length>0&&i.push(t),i}cleanupInputFormula(r){const e=[];return r.split('"').forEach((i,a)=>{a%2===0&&(i=i.replace(/[\s]+/g,""),Object.keys(c).forEach(s=>{i=i.replace(new RegExp(`\\b${s}\\b`,"g"),`[${s}]`)})),e.push(i)}),e.join('"')}parse(r){return r=this.cleanupInputFormula(r),this._do_parse(r)}_do_parse(r){let e=r.length-1,t=0,i="initial",a=[],s="",o="",N=null,g=0,w="";for(;t<=e;){switch(i){case"initial":if(s=r.charAt(t),s.match(/[0-9.]/))i="within-nr",o="",t--;else if(this.isOperator(s)){if(s==="-"&&(a.length===0||this.isOperatorExpr(a[a.length-1]))){i="within-nr",o="-";break}if(t===e||this.isOperatorExpr(a[a.length-1])){i="invalid";break}else a.push(l.createOperatorExpression(s,new l,new l)),i="initial"}else s==="("?(i="within-parentheses",o="",g=0):s==="["?(i="within-named-var",o=""):s.match(/["']/)?(i="within-string",w=s,o=""):s.match(/[a-zA-Z]/)&&(t<e&&r.charAt(t+1).match(/[a-zA-Z0-9_.]/)?(o=s,i="within-func"):(a.length>0&&a[a.length-1]instanceof m&&a.push(l.createOperatorExpression("*",new l,new l)),a.push(new y(s,this)),this.registerVariable(s),i="initial",o=""));break;case"within-nr":s=r.charAt(t),s.match(/[0-9.]/)?(o+=s,t===e&&(a.push(new m(o)),i="initial")):(o==="-"&&(o="-1"),a.push(new m(o)),o="",i="initial",t--);break;case"within-func":if(s=r.charAt(t),s.match(/[a-zA-Z0-9_.]/))o+=s;else if(s==="(")N=o,o="",g=0,i="within-func-parentheses";else throw new Error("Wrong character for function at position "+t);break;case"within-named-var":if(s=r.charAt(t),s==="]")a.push(new y(o,this)),this.registerVariable(o),o="",i="initial";else if(s.match(/[a-zA-Z0-9_.]/))o+=s;else throw new Error("Character not allowed within named variable: "+s);break;case"within-string":s=r.charAt(t),s===w?(a.push(new m(o,"string")),o="",i="initial",w=""):o+=s;break;case"within-parentheses":case"within-func-parentheses":if(s=r.charAt(t),w)s===w&&(w=""),o+=s;else if(s===")")if(g<=0){if(i==="within-parentheses")a.push(new S(this._do_parse(o)));else if(i==="within-func-parentheses"){let k=this.splitFunctionParams(o).map(P=>this._do_parse(P));a.push(new M(N,k,this)),N=null}i="initial"}else g--,o+=s;else s==="("?(g++,o+=s):(s.match(/["']/)&&(w=s),o+=s);break}t++}if(i!=="initial")throw new Error("Could not parse formula: Syntax error.");return this.buildExpressionTree(a)}buildExpressionTree(r){if(r.length<1)throw new Error("No expression given!");const e=[...r];let t=0,i=null;for(;t<e.length;)if(i=e[t],i instanceof d){if(t===0||t===e.length-1)throw new Error("Wrong operator position!");i.base=e[t-1],i.exponent=e[t+1],e[t-1]=i,e.splice(t,2)}else t++;for(t=0,i=null;t<e.length;)if(i=e[t],i instanceof x){if(t===0||t===e.length-1)throw new Error("Wrong operator position!");i.left=e[t-1],i.right=e[t+1],e[t-1]=i,e.splice(t,2)}else t++;for(t=0,i=null;t<e.length;)if(i=e[t],i instanceof b){if(t===0||t===e.length-1)throw new Error("Wrong operator position!");i.left=e[t-1],i.right=e[t+1],e[t-1]=i,e.splice(t,2)}else t++;if(e.length!==1)throw new Error("Could not parse formula: incorrect syntax?");return e[0]}isOperator(r){return typeof r=="string"&&r.match(/[+\-*/^]/)}isOperatorExpr(r){return r instanceof b||r instanceof x||r instanceof d}registerVariable(r){this._variables.indexOf(r)<0&&this._variables.push(r)}getVariables(){return this._variables}evaluate(r){if(r instanceof Array)return r.map(t=>this.evaluate(t));let e=this.getExpression();if(!(e instanceof l))throw new Error("No expression set: Did you init the object with a Formula?");if(this.options.memoization){let t=this.resultFromMemory(r);return t!==null||(t=Number(e.evaluate({...c,...r})),this.storeInMemory(r,t)),t}return Number(e.evaluate({...c,...r}))}hashValues(r){return JSON.stringify(r)}resultFromMemory(r){let e=this.hashValues(r),t=this._memory[e];return t!==void 0?t:null}storeInMemory(r,e){this._memory[this.hashValues(r)]=e}getExpression(){return this.formulaExpression}getExpressionString(){return this.formulaExpression?this.formulaExpression.toString():""}static calc(r,e=null,t={}){return e=e!=null?e:{},new u(r,t).evaluate(e)}};n(u,"Expression",l),n(u,"BracketExpression",S),n(u,"PowerExpression",d),n(u,"MultDivExpression",x),n(u,"PlusMinusExpression",b),n(u,"ValueExpression",m),n(u,"VariableExpression",y),n(u,"FunctionExpression",M),n(u,"MATH_CONSTANTS",c),n(u,"functionBlacklist",Object.getOwnPropertyNames(u.prototype).filter(r=>u.prototype[r]instanceof Function).map(r=>u.prototype[r]));let v=u;return v});
//# sourceMappingURL=fparser.umd.cjs.map
